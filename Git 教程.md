# Git 教程 

## Git记录的是什么

1. SVN记录的是每一次版本变动的内容
2. Git则是将每个版本独立保存





## Git的三棵树

1. 工作区域、暂存区域和Git仓库
   1. 工作区域





## Git工作流程

1. Git的工作流程一般是这样：
   1. 在工作目录中添加、修改文件
   2. 将需要进行版本管理的文件放入暂存区域
   3. 将暂存区域的文件提交到Git仓库
2. Git管理的文件有三个状态
   + 已修改（modified）
   + 已暂存（staged）
   + 已提交（committed）



### 具体代码！

#### 针对工作区域

##### 添加已更改的文件到暂存区

```git
git add <File> // 将工作目录未被追踪的文件添加到暂存区
```

#### 针对暂存区

##### 撤销最近一次向暂存区添加文件

```git
//如果想撤销掉此次添加，可以使用如下命令，恢复到添加前的状态
git reset HEAD <File>
//如果提交的有多个文件的话，指明File就可以精确地恢复，如果不指定的话，就会恢复刚才add的所有文件
```

##### 本地文件与暂存区文件内容不一致

```git
git add <File> // 重新添加
git checkout -- <File> // 可以用暂存区的版本覆盖掉本地的版本
```

##### 刚刚把修改过的文件添加到暂存区 又把那个文件修改了

```git
//如果直接commit
git commit -m "卧槽"  //就会只提交暂存区内的文件版本

//如果想用最新版本的文件
git add <File> //用最新版本文件覆盖掉旧版本的文件
```





## 查看工作状态和历史提交

### 查看状态 git status



### 查看日志git log





## 回到过去（版本回退命令 reset和checkout）

![三棵树与彼此的瓜西](C:\Users\aira\AppData\Roaming\Typora\typora-user-images\1590307713829.png)

主要介绍reset命令 

```git
git reset HEAD~ //把指向最近版本git仓库的指针移向上一个版本
git reset HEAD~10   //10 就是回退几个版本

git reset 版本号 //直接回滚到指定版本 可以前滚也可以后滚
```

此时 暂存区和git仓库都会回退到上一个版本，但是本地工作区还是不会受到影响，所以会恢复到**本地文件和暂存区文件版本不一致**的状态。



```git
git reset 版本快照 文件名/路径 //回滚个别文件
git reflog 					//查看全部的版本快照
```





### reset命令的选项（--mixed --soft --hard）

```git
git reset --mixed HEAD~
// --mixed是默认选项 会影响两棵树
// step1：移动HEAD的指向，将其指向上一个快照
// step2：将HEAD移动后指向的快照回滚到暂存区域

git reset --soft HEAD~  //撤销一次错误的提交命令，只影响一棵树
// step1：移动HEAD的指向，将其指向上一个快照

git reset --hard HEAD~ //有危险，会搞掉你最近辛辛苦苦修改的文件
// step1：移动HEAD的指向，将其指向上一个快照
// step2：将HEAD移动后指向的快照回滚到暂存区域
// step3:将暂存区域的文件还原到工作目录
```



## 版本对比 diff

### 比较暂存区域和工作目录

```git
git diff //比较
```

![代码执行结果](C:\Users\aira\AppData\Roaming\Typora\typora-user-images\1590310035999.png)

**显示不下！**

#### 跳转命令

j向下移动一行 

k向上移动一行

f一下向下移动一页

b一下网上移动一页

d向下移动半页

u向上移动半页

g 移动到第一行

G移动到最后一行

数字+g 就是移动到指定行



#### 搜索命令

/ + 搜索内容



### 对比两个版本快照
```git
git diff 版本快照ID1 版本快照ID2
```



### 对比当前工作目录和Git仓库中的快照

```git
git diff 快照ID
```



### 对比暂存区和Git仓库的快照

```git
git diff cached [指定快照ID] //默认为最新版本快照 
```

![终极奥义图](C:\Users\LJW20\AppData\Roaming\Typora\typora-user-images\1590310746407.png)





## 修改最后一次提交、删除文件和重命名文件

### 修改最后一次提交

+ 版本刚提交到仓库，突然想起漏掉了两个文件还没添加
+ 版本一提交到仓库，想起来版本说明写的不全面，无法彰显本次修改的重大意义
+ **解决方案**：执行带 --amend选项的 commit命令 就可以 **更正**最近一次的提交。



```git
git commit --amend [-m "修改内容"] // 默认进入提交文件内部直接修改提交文件
//也可以添加后面的可选参数直接 直接“更正”最近一次提交
```



### 删除文件

```git
git rm 文件名
//该命令删除的只是工作目录和暂存区域的我呢缉拿，也就是取消跟踪，在下次提交时不纳入版本管理。
```



```git
git rm -f 文件名
//当工作目录和暂存区域的同一文件存在不同内容时，可以把两个命令全部删除
```



```git
git rm --cached 文件名
//上述情况，只删除暂存区域的文件，保留工作目录的文件。
```



### 重命名文件

git只追踪文件名称，如果你自己修改文件名 ，git会认为你删除了源文件，添加了一个新文件。

```git
git mv 旧文件 新文件
```



 	

## Git分支管理

![分支很重要！](C:\Users\LJW20\AppData\Roaming\Typora\typora-user-images\1590327895474.png)

**git保存每个分支都是保存全部的副本，花费了较多的空间，节省了更多时间**



### 创建分支

```git 
git branch 分支名
```



### 切换分支

```git
git checkout 分支名
git checkout -b 分支名  //创建并切换到分支
```



```git
git log --decorate //可以打印版本相关的信息。。具体还未总结
git log --decorate --oneline --graph --all //可以查看所有分支及其快照拥有情况
```



### 合并分支

```git
git merge 分支名 //可以将指定分支合并到目前的分支
```

可能会产生冲突



### 匿名分支

如果你选择了切换分支而不指定分支名，就会创建一个匿名分支，匿名分支上所有的修改都会丢失，不会对原来的分支有任何影响，所以可以在匿名分支上进行一些实验性的修改

如果想保留分支的话，可以根据指示，通过 

```git
git branch <new-branch-name> 分支id //就会创建一个新的分支来保留修改。
```



### checkout命令

- 从历史快照（或者暂存区域）中拷贝文件到工作目录
  - 当给定某个文件名的时候，Git会从指定的提交中拷贝文件到暂存区域和工作目录，比如执行git checkout HEAD~ README.md 的时候，会从上一个快照中把文件复制到工作目录和暂存区域
  - 如果没有指定具体的快照ID，就会从暂存区域恢复文件到指定目录（git checkout README.md）
- 切换分支（主要作用）
  - git的分支就是添加一个指向快照的指针，其次我们还知道切换分支除了修改HEAD指针的指向，还会改变暂存区域和工作目录的内容。



### 重点（checkout 和 reset）

1. 两者都可以用于恢复指定快照的指定文件，而且都不会改变HEAD指针的指向。
2. reset只将指定的文件恢复到暂存区域，而checkout会覆盖暂存区域和工作目录。 所以reset要比checkout安全一些
3. 从恢复快照方面
   1. 对reset --hard来说， checkout会更安全，因为checkout命令在切换分支前会先检查当前的工作状态是否为clean ，如果不是就不会让你做，但是reset就会直接覆盖数据
   2. reset会移动HEAD所在分支的指向，但是checkout只会移动HEAD自身来指向另一个分支。相当于reset直接让目标分支覆盖了当前分支，真的回到了从前！！